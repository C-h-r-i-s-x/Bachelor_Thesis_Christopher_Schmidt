/- Imports -/
import tactic
import tactic.qify

import ring_theory.prime
import ring_theory.multiplicity

import data.list.prime
import data.nat.sqrt

open nat 
open finset
open_locale nat big_operators
/-
# Lemmata Step 1 : 1-5
-/
lemma prime_div_desc_fac (n k m l p : ℕ) (h_1lel : 1 ≤ l) (h_4lek : 4 ≤ k) 
  (h_klen : k ≤ n) (h_p : prime p) (h_p_div_binom : p ∣ choose n k) (h_klp : k < p) 
  (H : choose n k = m^l) :
  p^l ∣ n.desc_factorial k :=
begin
  -- helpful / needed features
  have h_fac_div : (↑k! * ↑(n - k)!) ∣ (n! : ℤ) := by
  { norm_cast,
    exact factorial_mul_factorial_dvd_factorial h_klen, },
  have h_fac_div' : ↑(n - k)! ∣ (n! : ℤ) := 
    dvd_of_mul_left_dvd h_fac_div,
  have h_fac_div'' :  (k! : ℤ) ∣ (↑n! / ↑(n - k)!) := by
  { norm_cast,
    refine (dvd_div_iff ((int.coe_nat_dvd).mp h_fac_div')).mpr _,
    norm_cast at h_fac_div,
    rw mul_comm,
    exact h_fac_div, },
  have h_kfac_ne_zero : (k! : ℚ) ≠ 0 := 
    cast_ne_zero.mpr (factorial_ne_zero k),
  have h_nkfac_ne_zero : ((n - k)! : ℚ) ≠ 0 :=
    cast_ne_zero.mpr (n - k).factorial_ne_zero,
  have h_facprod_ne_zero : (k! * (n - k)! : ℚ) ≠ 0 := 
    mul_ne_zero h_kfac_ne_zero h_nkfac_ne_zero,
  -- p^l ∣ n! / (k! * (n-k)!)
  have h_pl_div_fac : p^l ∣ (n.factorial / (k.factorial * (n-k).factorial)) := by
  { rw ← nat.choose_eq_factorial_div_factorial h_klen,
    have h_pl_div_binom : p^l ∣ choose n k := by
    { rw H,
      rw H at h_p_div_binom,
      have h_p_div_m : p ∣ m := prime.dvd_of_dvd_pow (h_p)(h_p_div_binom),
      exact pow_dvd_pow_of_dvd h_p_div_m l, },
    exact h_pl_div_binom, },
  -- using qify to handle devision and to rewrite h_pl_div_fac to
  -- p^l ∣ n! / (n-k)! / k!
  have h_fraction: (n.factorial / (k.factorial * (n - k).factorial)) =
    (n.factorial / (n - k).factorial) / k.factorial := by
  { zify,
    qify,
    field_simp,
    rw mul_comm,
    left,
    refl, },
  rw h_fraction at h_pl_div_fac,
  -- obtain that p^l ∣ n! / (n-k)!
  have h_pl_div_fac_part: p^l ∣ (n.factorial / (n - k).factorial) := by
  { have h_eq_pl_with_k := exists_eq_mul_right_of_dvd h_pl_div_fac,
    have h_eq_pl : ∃ (r : ℕ), r * p^l = n.factorial / (n - k).factorial := by
    { cases h_eq_pl_with_k with j h_eq,
      use (j * k.factorial),
      have h_rew : j * k.factorial * p^l = p^l * j * k.factorial := by
      { simp only [mul_comm, mul_assoc], },
      rw h_rew,
      rw ← h_eq,
      zify,
      qify,
      field_simp,
      rw mul_comm ((n - k)! : ℚ) _,
      rw mul_assoc, },
    cases h_eq_pl with j h_eq,
    exact dvd.intro_left j h_eq, },
  -- p^l ∣ n.desc_factorial k because 
  -- n.desc_factorial = n! / (n-k)!
  convert  h_pl_div_fac_part,
  exact desc_factorial_eq_div h_klen,
end

lemma desc_factorial_eq_prod (n : ℕ) : ∀ (k : ℕ), k ≤ n →
  n.desc_factorial k = ∏ i in range k, (n - i) :=
begin
  induction n with n hn,
  { intros h h_klen,
    rw le_zero_iff.mp h_klen,
    simp only 
      [nat.desc_factorial_zero, zero_tsub, range_zero, 
      prod_const, card_empty, pow_zero], },
  { intro k,
    cases k,
    { have := hn 0 (zero_le n),
      intros hsucc,
      simp only [nat.desc_factorial_zero, range_zero, prod_empty], },
    { intro h_klenn,
    rw nat.succ_desc_factorial_succ,
    have h_4lek_n := nat.succ_le_succ_iff.mp h_klenn,
    rw hn k h_4lek_n,
    rw prod_range_succ',
    simp only [nat.succ_sub_succ_eq_sub, tsub_zero],
    rw mul_comm,}, },
end

lemma prime_dvd_prod (p : ℕ) (hp : prime p) {s : finset ℕ } {f : ℕ → ℕ}:
p ∣ ∏ i in s, f i → ∃ i, i ∈ s ∧ p ∣ (f i) :=
begin
  rw ← prod_to_list,
  intro h,
  have := (prime.dvd_prod_iff (hp)).mp h,
  cases this with i hi,
  simp at hi,
  cases hi with hi hpi,
  cases hi with j hj,
  use j,
  cases hj,
  rw ← hj_right at hpi,
  exact ⟨hj_left, hpi⟩,
end

lemma desc_factorial_div_fac (n k p : ℕ) (h_klen : k ≤ n) (hp : _root_.prime p)
(h : p ∣ n.desc_factorial k) : ∃ i ∈ range k, p ∣ n - i :=
begin
  rw desc_factorial_eq_prod n k h_klen at h,
  convert prime_dvd_prod p hp h,
  simp only [mem_Ico, zero_le', true_and, exists_prop, mem_range],
end

lemma factor_in_desc_factorial (n k p l : ℕ) (h_klen : k ≤ n) (h_klp : k < p) 
(hp: _root_.prime p ) (h_pow_div: p^l ∣ n.desc_factorial k) ( h_1lel : 1 ≤ l):
∃ (i : ℕ), (i ≤ k - 1) ∧ p^l ∣ (n - i) :=
begin
  -- ∃! i : p ∣ (n-i)
  have h_one_fac : ∃! i ∈ (range k), p ∣ (n - i) := by
  { -- ∃ i : p ∣ (n-i)
    have h_exists : ∃ (i : ℕ), i  ∈ (range k) ∧ p ∣ (n - i) := by
    { have h_div : p ∣ n.desc_factorial k := by
      { have h_p_div_pl : p ∣ p^l := by
        { nth_rewrite 0 ←pow_one p,
          exact pow_dvd_pow p h_1lel, },
        exact dvd_trans h_p_div_pl h_pow_div, },
      have := desc_factorial_div_fac n k p h_klen hp h_div,
      cases this with j hj,
      use j,
      simp at hj,
      cases hj,
      exact ⟨mem_range.mpr hj_left, hj_right ⟩, },
    cases h_exists with i h_i,
    -- uniqueness of i
    have h_unique : (i ∈ range k ∧ p ∣ n - i) ∧
                 ∀ (y : ℕ), y ∈ range k → p ∣ n - y → y = i := by
    { split,
      {exact h_i,},
      { cases h_i,
        intros j h_j_left h_j_right,
        simp only [nat.Ico_zero_eq_range, mem_range] at h_j_left,
        simp only [nat.Ico_zero_eq_range, mem_range] at h_i_left,
        cases h_j_right with q_j,
        cases h_i_right with q_i,
        have h_in : i ≤ n := le_trans (le_of_lt h_i_left) h_klen,
        have h_jn : j ≤ n := le_trans (le_of_lt h_j_left) h_klen,
        zify at *,
        have h_i_sub_j : (i : ℤ) - j = p*(q_j - q_i) := by
        { have h : (n : ℤ) - j - (n - i) = p * q_j - p * q_i :=
            congr (congr_arg has_sub.sub h_j_right_h) h_i_right_h,
          simp only [sub_sub_sub_cancel_left] at h,
          rw mul_sub,
          exact h,},
        have h_abs : |(i : ℤ) - j| < k := by
        { have h_pos : (i : ℤ) - j < k - 0 := by
          { have h_help : 0 ≤ j := by
            { exact zero_le j, },
            zify at h_help,
            exact int.sub_lt_sub_of_lt_of_le h_i_left h_help, },
          simp only [tsub_zero] at h_pos,
          have h_neg : -((i : ℤ) - j) < k - 0 := by
          { simp only [neg_sub],
            exact int.sub_lt_sub_of_lt_of_le h_j_left (cast_nonneg i), },
          simp only [neg_sub, tsub_zero] at h_neg,
          cases em ((i : ℤ) - j ≤ 0),
          { have h_help : |(i : ℤ) - j | = -(i - j) := abs_of_nonpos h,
            rw h_help,
            norm_num,
            exact h_neg, },
          { have : (i : ℤ) - j ≥ 0 := by { exact le_of_not_ge h, },
            have h_help : |(i : ℤ) - j| = i - j := abs_of_nonneg this,
            rw h_help,
            exact h_pos, }, },
        have h_abs' : |(i : ℤ) - j| < p := by
        { exact lt_trans h_abs h_klp, },
        have h_abs_div: (p : ℤ) ∣ |(i : ℤ) - j| := by
        { simp only [dvd_abs],
          use (↑q_j - (q_i : ℤ)),
          exact h_i_sub_j, },
        have h_q_diff_zero : |((i : ℤ) - j)| = 0 :=
          int.eq_zero_of_dvd_of_nonneg_of_lt (abs_nonneg (↑i - ↑j)) h_abs' h_abs_div,
        have h_diff : (i : ℤ) - j = 0 := by
        { exact abs_eq_zero.mp h_q_diff_zero, },
        have h_help : (i : ℤ) = j := by
        { exact sub_eq_zero.mp h_diff},
        exact eq.symm h_help, }, },
    -- combining the previous two hypothesis
    refine ⟨i, _⟩,
    simp only [true_and, exists_unique_iff_exists, exists_prop, and_imp],
    exact h_unique, },
  --
  have h : ∃ j1 j2, p ∣ (n - j1) ∧ p ∣ (n - j2) → j1 = j2 := by
  {  sorry, },
  -- ∃ i : p^l ∣ (n-i)
  simp only [mem_range, exists_unique_iff_exists, exists_prop] at h_one_fac,
  cases h_one_fac with i h_one_fac',
  use i,
  split,
  { have h_l : i < k → i ≤ k-1 := le_pred_of_lt, 
    have h_r : i ≤ k - 1 → i < k := by
    { intro h,
      linarith, }, 
    have h_b : i < k ↔ i ≤ k-1 := {mp := h_l, mpr := h_r},
    rw ← h_b,
    linarith,},
  { sorry, },
end
/-
# Sylvester's Theorem
-/
theorem sylvester (k n : ℕ) (h : n ≥ 2*k): ∃ p, p > k ∧ prime p ∧ p ∣ choose n k :=
begin
  sorry,
end
/-
# Legendre's Theorem
-/
theorem legendre {p : ℕ} (hp : prime p) : ∀ {n b : ℕ}, log p n < b → 
  multiplicity p n! = (∑ i in Ico 1 b, n / p ^ i : ℕ) :=
begin
  sorry,
end
/-
# Erdos' Theorem
-/
theorem binomials_coefficients_never_powers (k l m n : ℕ) (h_2lel : 2 ≤ l) 
(h_4lek : 4 ≤ k) (h_klen4 : k ≤ n - 4) : choose n k ≠ m^l :=
begin 
  have h_wlog : ∀ (k' : ℕ) (h_4lek' : 4 ≤ k') (h_klen4' : k' ≤ n - 4), 
    2*k' ≤ n → choose n k' ≠ m^l := by
  { clear h_4lek h_klen4 k,
    intros k h_4lek h_klen4 h,
    -- inequalities needed
    have h_klen : k ≤ n := le_trans h_klen4 (nat.sub_le n 4),
    have h_1lel : 1 ≤ l := le_of_succ_le (h_2lel),
    -- proof by contradiciton
    by_contra H,
    -- main proof here proceeding in four steps
    -- STEP (1) : ∃ p prim : n ≥ p^l > k^l ≥ k²
    have h₁: ∃ p, prime p ∧ p^l ≤ n ∧ k^l < p^l ∧ k^2 ≤ k^l := by
    { cases (sylvester k n h) with p hp,
      cases hp with h_klp h_right,
      cases h_right with h_p h_p_div_binom,
      -- now we have p : ℕ , h_p : prime p , h_pdivbinom : p | n.choose k
      -- we want to use the from sylvester's theorem obtained p for our proof
      use p,
      split,
      -- prove that p is prime
      { exact h_p, },
      { split,
        -- prove p^l ≤ n
        { have h_pl_div_desc: p^l ∣ n.desc_factorial k := by
          { exact prime_div_desc_fac n k m l p h_1lel h_4lek h_klen h_p h_p_div_binom h_klp H, },
          have h_klp_pow_dvd := factor_in_desc_factorial n k p l h_klen (gt_iff_lt.mp h_klp) (h_p)
            h_pl_div_desc h_1lel,
          cases h_klp_pow_dvd with i hi,
          cases hi,
          have : p^l ≤ n - i := by
          { refine  nat.le_of_dvd _ hi_right,
            simp only [tsub_pos_iff_lt],
            have h_ilk : i < k := by
            { have hk : 0 < k := lt_of_lt_of_le four_pos h_4lek,
              zify at hi_left,
              zify,
              exact int.lt_of_le_sub_one hi_left, },
            exact lt_of_lt_of_le h_ilk h_klen, },
          have h_klen4i : n - i ≤ n := nat.sub_le n i,
          exact le_trans this h_klen4i, },
        { split,
          -- prove k^l < p^l
          { exact nat.pow_lt_pow_of_lt_left (h_klp)(gt_of_ge_of_gt h_2lel two_pos), },
          -- prove k² ≤ k^l
          { exact nat.pow_le_pow_of_le_right (pos_of_gt h_4lek) h_2lel,  }, }, }, },





    sorry, },
  cases em (n ≥ 2*k) with h_2k,
  { exact h_wlog k h_4lek h_klen4 h_2k},
  { -- transform ¬(n ≥ 2 * k) into (n < 2 * k)
    simp only [not_le] at h,
    -- transform (n.choose k) into (n.choose (n - k))
    have h_klen : k ≤ n := le_trans h_klen4 (nat.sub_le n 4),
    rw ←choose_symm h_klen,
    -- define k' as n - k, such that k' can be used for h_wlog as k'
    -- satisfies all required features
    let k' := n - k,
    have h_k'_def : k' = n - k := by refl,
    -- third requirement: 2 * k' ≤ n
    have h_2k'len : 2 * k' ≤ n := by
    { zify,
      have h': n ≤ 2 * k := le_of_lt h,
      zify at h',
      ring_nf,
      rw sub_le_iff_le_add,
      have := add_le_add_right h' n,
      ring_nf at this,
      exact this, },
    -- second requirement: k ≤ n - 4
    have h_k'len4 : k' ≤ n - 4 := by
    { simp [h_k'_def],
      have help : k + k ≤ n - 4 + k := add_le_add_right h_klen4 k,  
      rw ← (two_mul k) at help,
      exact le_trans (le_of_lt h) help, },
    -- first requirement: 4 ≤ k
    have h_4lek' : 4 ≤ k' := by 
    { have h_4len : 4 ≤ n := le_trans (le_trans h_4lek h_klen4) (nat.sub_le n 4),
      linarith, },
    -- now we can use h_wlog
    exact h_wlog k' h_4lek' h_k'len4 h_2k'len,},
end
